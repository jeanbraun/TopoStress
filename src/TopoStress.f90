!-----------------

subroutine TopoStresses ()

! computes elastic stresses generated by a finite amplitude topography

! h is topography defined on an nx by ny rectangular mesh
! nx and ny are the size of that mesh
! nz is the vertical discretization (number of nodes in the z-direction)
! xl, yl, zl are the three dimensions of the volume of crust in which the computations are performed
!  note that h is added to zl
! rhog is the product of rock density (in kg/m^3) by the gravitational acceleration g (in m/s^2)
! ym is Young modulus in Pa
! pr is Poisson's ratio (dimensionless)
! ks is von Mises yield stress (linear elastic if negative)
! exx and eyy are imposed strains on the horizontal sides of the domain (compressive
!   is negative)
! ibc is the type of boundary conditions along the side walls:
!   = 0 free boundaries
!   = 1 fixed boundaries
!   = 2 no slip boundaries
!   = 3 no-tilt boundaries
! stress is an array of dimension (6,nn) containing the stresses in Pa
! The convention is that the 6 components of stress are stored in the following order:
!   sxx,syy,szz,sxy,sxz,syz, for each of the nodes
!   nn is the product of nx*ny*nz; stress must be dimensioned in the calling
!   routine (as well as h)

use TopoStressesContext

implicit none

integer npe,iint,nint,ndof,iop
double precision c(6,6),cw(6,6),ce(6,6)
integer, dimension(:,:), allocatable :: icon,ifix
double precision, dimension(:), allocatable :: x,y,z,fel,uvw,rhs
double precision, dimension(:,:), allocatable :: ael,f,fix,stressp,stressn
integer, dimension(:), allocatable :: ncont
double precision, dimension(:,:,:), allocatable :: a
integer i,j,k,ijk,ic,ie,iter
logical vocal,nonlinear,converge

vocal=.true.
nonlinear=.true.
if (ks<0.) nonlinear=.false.

npe=8
nint=8

allocate (icon(npe,ne))
allocate (x(nn),y(nn),z(nn),uvw(nn*3),rhs(nn*3),ifix(3,nn),fix(3,nn))
allocate (ael(3*npe,3*npe),a(3*npe,3*npe,ne),fel(3*npe),f(3*npe,ne))
allocate (stressp(6,ne),stressn(6,ne),ncont(nn))

! computes the location of the nodes

if (vocal) print*,'Computing node locations'

ifix=0
fix=0.d0
  do k=1,nz
    do j=1,ny
      do i=1,nx
      ijk=i+(j-1)*nx+(k-1)*nx*ny
      x(ijk)=xl*float(i-1)/(nx-1)
      y(ijk)=yl*float(j-1)/(ny-1)
      z(ijk)=(zl+h2(i,j))*float(k-1)/(nz-1)
        if (ibc.eq.0) then
        elseif (ibc.eq.1) then
          if (i.eq.1) then
          ifix(1,ijk)=1
          fix(1,ijk)=-exx*xl/2.d0
          ifix(2,ijk)=1
          ifix(3,ijk)=1
          elseif (i.eq.nx) then
          ifix(1,ijk)=1
          fix(1,ijk)=exx*xl/2.d0
          ifix(2,ijk)=1
          ifix(3,ijk)=1
          endif
          if (j.eq.1) then
          ifix(2,ijk)=1
          fix(2,ijk)=-eyy*yl/2.d0
          ifix(1,ijk)=1
          ifix(3,ijk)=1
          elseif (j.eq.ny) then
          ifix(2,ijk)=1
          fix(2,ijk)=eyy*yl/2.d0
          ifix(1,ijk)=1
          ifix(3,ijk)=1
          endif  
        elseif (ibc.eq.2) then
          if (i.eq.1) then
          ifix(1,ijk)=1
          fix(1,ijk)=-exx*xl/2.d0
          elseif (i.eq.nx) then
          ifix(1,ijk)=1
          fix(1,ijk)=exx*xl/2.d0
          endif
          if (j.eq.1) then
          ifix(2,ijk)=1
          fix(2,ijk)=-eyy*yl/2.d0
          elseif (j.eq.ny) then
          ifix(2,ijk)=1
          fix(2,ijk)=eyy*yl/2.d0
          endif
        elseif (ibc.eq.3) then
          if (i.eq.1) then
          ifix(1,ijk)=1
          elseif (i.eq.nx) then
          ifix(1,ijk)=1
          endif
          if (j.eq.1) then
          ifix(2,ijk)=1
          elseif (j.eq.ny) then
          ifix(2,ijk)=1
          endif
        else
        print*,'this type of ibc not implemented'
        endif
      if (k.eq.1) then
        ifix(3,ijk)=1
        if (ibc.eq.1) then
          ifix(1,ijk)=1
          ifix(2,ijk)=1
        endif
      endif
      enddo
    enddo
  enddo

! computes the connectivity array between nodes and elements (icon)

if (vocal) print*,'Computing connectivity'

ie=0
  do k=1,nz-1
    do j=1,ny-1
      do i=1,nx-1
      ie=ie+1
      icon(1,ie)=i+(j-1)*nx+(k-1)*nx*ny
      icon(2,ie)=icon(1,ie)+1
      icon(3,ie)=icon(1,ie)+nx
      icon(4,ie)=icon(1,ie)+nx+1
      icon(5,ie)=icon(1,ie)+nx*ny
      icon(6,ie)=icon(2,ie)+nx*ny
      icon(7,ie)=icon(3,ie)+nx*ny
      icon(8,ie)=icon(4,ie)+nx*ny
      enddo
    enddo
  enddo

converge=.false.
stressp=0.
iter=1

111 continue

if (nonlinear) print*,'Nonlinear Iteration: ',iter

! computes the elastic stress-strain matrix, c

if (vocal) print*,'Computing elastic matrix'

call make_c (c,ym,pr)
cw=c*1.d3
cw(1:3,1:3)=cw(1:3,1:3)/1.d9

! computes the elastic finite element stiffness matrix (a) and right hand side vector (f)
! note that both matrix/vector are stored in an element by element fashion, ie the complete
! (or assembled) matrix is not needed and will be computed in the solver (solve_skyline_renumber_n)

if (vocal) print*,'Computing FE matrix'

ie=0
  do k=1,nz-1
    do j=1,ny-1
      do i=1,nx-1
      ie=ie+1
      ce=c
      if (ibc.eq.2.and.(i.eq.1.or.i.eq.nx-1.or.j.eq.1.or.j.eq.ny-1)) ce=cw
      if (nonlinear) call plastic (ce,stress(1,ie),ks)
      a(:,:,ie)=0.d0
      f(:,ie)=0.d0
      ael=0.d0
      fel=0.d0
        do iint=1,nint
        call make_a (ie,iint,ael,fel,npe,x,y,z,nn,icon,ne,ce,rhog,ifix,fix)
        a(:,:,ie)=a(:,:,ie)+ael
        f(:,ie)=f(:,ie)+fel
        enddo
      enddo
    enddo
  enddo

! the global (nodal) rhs vector is built

if (vocal) print*,'Computing RHS vector'

rhs=0.d0
  do ie=1,ne
    do k=1,npe
    ic=icon(k,ie)
    rhs(ic*3-2)=rhs(ic*3-2)+f(k*3-2,ie)
    rhs(ic*3-1)=rhs(ic*3-1)+f(k*3-1,ie)
    rhs(ic*3-0)=rhs(ic*3-0)+f(k*3-0,ie)
    enddo
  enddo

! the displacement vector is computed by solving the algebraic system of equations

if (vocal) print*,'Computing solution'

ndof=3
iop=2
call solve_skyline_renumber_n (ndof,npe,a,rhs,uvw,icon,nn,ne,iop)

! the stresses are stored in a vtk file for display

if (vocal) print*,'Computing stresses'

call compute_stress (x,y,z,uvw,stressn,nn,ne,icon,ym,pr)

if (vocal) print*,'Check for convergence'

call check_convergence (stressn,stressp,converge,ne)

iter=iter+1
if (nonlinear.and..not.converge) goto 111

stress=0.d0
ncont=0
  do ie=1,ne
    do k=1,npe
    ic=icon(k,ie)
    stress(:,ic)=stress(:,ic)+stressn(:,ie)
    ncont(ic)=ncont(ic)+1
    enddo
  enddo
  do i=1,nn
  if (ncont(i).ne.0) stress(:,i)=stress(:,i)/ncont(i)
  enddo

deallocate (icon)
deallocate (x,y,z,uvw,rhs,ifix,fix)
deallocate (ael,a,fel,f)
deallocate (stressp,stressn)
deallocate (ncont)

end subroutine TopoStresses

!-----------------

subroutine make_a (ie,iint,a,f,npe,x,y,z,nn,icon,ne,c,rhog,ifix,fix)

! subroutine to build the finite element stiffness matrix and corresponding right hand side vector
! this is done for a single element, ie and integration point iint
! npe is the number of nodes per element
! x,y,z are the global nodal  coordinates
! nn is the number of nodes
! icon is the elemental connectiviy matrix providing the node numbers per element
! ne is the number of elements
! c is the elasticity constitutive matrix
! rhog is the product of rock density (in kg/m^3) by gravitational acceleration (in m/s^2)

implicit none

integer npe,nn,ne,ie,iint
double precision b(3*npe,6),bc(3*npe,6),a(3*npe,3*npe),f(3*npe)
double precision x(nn),y(nn),z(nn),c(6,6),fix(3,nn)
integer icon(npe,ne),ifix(3,nn)
integer k1,k2,k3,i,j,k,ic
double precision r,s,t,w,volume,rhog,aref
double precision h(8)
double precision dhdr(8),dhds(8),dhdt(8)
double precision dhdx(8),dhdy(8),dhdz(8)
double precision jcb(3,3),jcbi(3,3)

double precision, dimension (8) :: ww,rr,ss,tt

ww=(/1.d0,1.d0,1.d0,1.d0,1.d0,1.d0,1.d0,1.d0/)
rr=(/ &
-.577350269189626d0, &
 .577350269189626d0, &
 .577350269189626d0, &
-.577350269189626d0, &
-.577350269189626d0, &
 .577350269189626d0, &
 .577350269189626d0, &
-.577350269189626d0 /)
ss=(/ &
-.577350269189626d0, &
-.577350269189626d0, &
 .577350269189626d0, &
 .577350269189626d0, &
-.577350269189626d0, &
-.577350269189626d0, &
 .577350269189626d0, &
 .577350269189626d0 /)
tt=(/ &
 -.577350269189626d0, &
 -.577350269189626d0, &
 -.577350269189626d0, &
 -.577350269189626d0, &
  .577350269189626d0, &
  .577350269189626d0, &
  .577350269189626d0, &
  .577350269189626d0 /)

! rr,ss,tt and the local coordinates of the Gauss-Legendre integration points
! ww are the wieght associated with each of the integration point

r=rr(iint)
s=ss(iint)
t=tt(iint)
w=ww(iint)

! h is the interpolation or shape function vector
! here we assume that the element is linear in all three directions
! the elements are deformed cubes (or parallelipipeds)
! note that this can be modified easily to use triangulat prismatic elements

h(1)=(1.d0-r)*(1.d0-s)*(1.d0-t)/8.d0
h(2)=(1.d0+r)*(1.d0-s)*(1.d0-t)/8.d0
h(3)=(1.d0-r)*(1.d0+s)*(1.d0-t)/8.d0
h(4)=(1.d0+r)*(1.d0+s)*(1.d0-t)/8.d0
h(5)=(1.d0-r)*(1.d0-s)*(1.d0+t)/8.d0
h(6)=(1.d0+r)*(1.d0-s)*(1.d0+t)/8.d0
h(7)=(1.d0-r)*(1.d0+s)*(1.d0+t)/8.d0
h(8)=(1.d0+r)*(1.d0+s)*(1.d0+t)/8.d0

! dhdr, dhds and dhdt are the spatial derivative matrices in the (r,s,t) local systel of reference

dhdr(1)=-(1.d0-s)*(1.d0-t)/8.d0
dhdr(2)=(1.d0-s)*(1.d0-t)/8.d0
dhdr(3)=-(1.d0+s)*(1.d0-t)/8.d0
dhdr(4)=(1.d0+s)*(1.d0-t)/8.d0
dhdr(5)=-(1.d0-s)*(1.d0+t)/8.d0
dhdr(6)=(1.d0-s)*(1.d0+t)/8.d0
dhdr(7)=-(1.d0+s)*(1.d0+t)/8.d0
dhdr(8)=(1.d0+s)*(1.d0+t)/8.d0

dhds(1)=-(1.d0-r)*(1.d0-t)/8.d0
dhds(2)=-(1.d0+r)*(1.d0-t)/8.d0
dhds(3)=(1.d0-r)*(1.d0-t)/8.d0
dhds(4)=(1.d0+r)*(1.d0-t)/8.d0
dhds(5)=-(1.d0-r)*(1.d0+t)/8.d0
dhds(6)=-(1.d0+r)*(1.d0+t)/8.d0
dhds(7)=(1.d0-r)*(1.d0+t)/8.d0
dhds(8)=(1.d0+r)*(1.d0+t)/8.d0

dhdt(1)=-(1.d0-r)*(1.d0-s)/8.d0
dhdt(2)=-(1.d0+r)*(1.d0-s)/8.d0
dhdt(3)=-(1.d0-r)*(1.d0+s)/8.d0
dhdt(4)=-(1.d0+r)*(1.d0+s)/8.d0
dhdt(5)=(1.d0-r)*(1.d0-s)/8.d0
dhdt(6)=(1.d0+r)*(1.d0-s)/8.d0
dhdt(7)=(1.d0-r)*(1.d0+s)/8.d0
dhdt(8)=(1.d0+r)*(1.d0+s)/8.d0

! jcb is the matrix rtepresenting the jacobian of the transformation between local (rst)
! and global (xyz) coordinates

jcb=0.
  do k=1,npe
  ic=icon(k,ie)
  jcb(1,1)=jcb(1,1)+dhdr(k)*x(ic)
  jcb(1,2)=jcb(1,2)+dhdr(k)*y(ic)
  jcb(1,3)=jcb(1,3)+dhdr(k)*z(ic)
  jcb(2,1)=jcb(2,1)+dhds(k)*x(ic)
  jcb(2,2)=jcb(2,2)+dhds(k)*y(ic)
  jcb(2,3)=jcb(2,3)+dhds(k)*z(ic)
  jcb(3,1)=jcb(3,1)+dhdt(k)*x(ic)
  jcb(3,2)=jcb(3,2)+dhdt(k)*y(ic)
  jcb(3,3)=jcb(3,3)+dhdt(k)*z(ic)
  enddo

! volume is the determinant of the jacobian which also represents the volume of the element

volume=jcb(1,1)*jcb(2,2)*jcb(3,3) &
      +jcb(1,2)*jcb(2,3)*jcb(3,1) &
      +jcb(2,1)*jcb(3,2)*jcb(1,3) &
      -jcb(1,3)*jcb(2,2)*jcb(3,1) &
      -jcb(1,2)*jcb(2,1)*jcb(3,3) &
      -jcb(2,3)*jcb(3,2)*jcb(1,1)

  if (volume.le.tiny(volume)) then
  stop 'Element bow-tied or collapsed'
  endif

! jcbi is the inverse of the jacobian

jcbi(1,1)=(jcb(2,2)*jcb(3,3)-jcb(2,3)*jcb(3,2))/volume
jcbi(2,1)=(jcb(2,3)*jcb(3,1)-jcb(2,1)*jcb(3,3))/volume
jcbi(3,1)=(jcb(2,1)*jcb(3,2)-jcb(2,2)*jcb(3,1))/volume
jcbi(1,2)=(jcb(1,3)*jcb(3,2)-jcb(1,2)*jcb(3,3))/volume
jcbi(2,2)=(jcb(1,1)*jcb(3,3)-jcb(1,3)*jcb(3,1))/volume
jcbi(3,2)=(jcb(1,2)*jcb(3,1)-jcb(1,1)*jcb(3,2))/volume
jcbi(1,3)=(jcb(1,2)*jcb(2,3)-jcb(1,3)*jcb(2,2))/volume
jcbi(2,3)=(jcb(1,3)*jcb(2,1)-jcb(1,1)*jcb(2,3))/volume
jcbi(3,3)=(jcb(1,1)*jcb(2,2)-jcb(1,2)*jcb(2,1))/volume

! dhdx, dhdy and dhdz are the spatial derivative matrices in the glocal system of reference (x,y,z)

  do k=1,npe
  dhdx(k)=jcbi(1,1)*dhdr(k)+jcbi(1,2)*dhds(k)+jcbi(1,3)*dhdt(k)
  dhdy(k)=jcbi(2,1)*dhdr(k)+jcbi(2,2)*dhds(k)+jcbi(2,3)*dhdt(k)
  dhdz(k)=jcbi(3,1)*dhdr(k)+jcbi(3,2)*dhds(k)+jcbi(3,3)*dhdt(k)
  enddo

! computes the B (or strain-displacement) vector

  do k=1,npe
  k1=(k-1)*3+1
  k2=(k-1)*3+2
  k3=(k-1)*3+3
  b(k1,1)=dhdx(k)
  b(k2,1)=0.d0
  b(k3,1)=0.d0
  b(k1,2)=0.d0
  b(k2,2)=dhdy(k)
  b(k3,2)=0.d0
  b(k1,3)=0.d0
  b(k2,3)=0.d0
  b(k3,3)=dhdz(k)
  b(k1,4)=0.d0
  b(k2,4)=dhdz(k)
  b(k3,4)=dhdy(k)
  b(k1,5)=dhdz(k)
  b(k2,5)=0.d0
  b(k3,5)=dhdx(k)
  b(k1,6)=dhdy(k)
  b(k2,6)=dhdx(k)
  b(k3,6)=0.d0
  enddo

! computes product of b by c the constitutive matrix

  do j=1,npe*3
    do i=1,6
    bc(j,i)=0.d0
      do k=1,6
      bc(j,i)=bc(j,i)+b(j,k)*c(k,i)
      enddo
    enddo
  enddo

! compute bTcb to form the stiffness matrix

  do j=1,npe*3
    do i=1,npe*3
    a(i,j)=0.d0
      do k=1,6
      a(i,j)=a(i,j)+b(i,k)*bc(j,k)*volume*w
      enddo
    enddo
  enddo

! computes rhs vector

  do i=1,npe
  f(i*3)=f(i*3)-h(i)*rhog*volume*w
  enddo

! add bc

do k=1,8
ic=icon(k,ie)
  do k1=1,3
    if (ifix(k1,ic).eq.1) then
    i=(k-1)*3+k1
    aref=a(i,i)
      do j=1,24
      f(j)=f(j)-a(j,i)*fix(k1,ic)
      a(i,j)=0.d0
      a(j,i)=0.d0
      enddo
    a(i,i)=aref
    f(i)=aref*fix(k1,ic)
    endif
  enddo
enddo

end subroutine make_a

!-----------------

subroutine make_c (c,ym,pr)

! subroutine to compute the elastic constitutive matrix c

implicit none

double precision c(6,6)
double precision ym,pr,c1,c2,c3,a1

a1=ym*(1.d0-pr)/(1.d0+pr)/(1.d0-2.d0*pr)
c1=a1
c2=a1*pr/(1.d0-pr)
c3=a1*(1.d0-2.d0*pr)/2.d0/(1.d0-pr)

c=0.d0
c(1,1)=c1
c(2,2)=c1
c(3,3)=c1
c(1,2)=c2
c(1,3)=c2
c(2,3)=c2
c(2,1)=c2
c(3,1)=c2
c(3,2)=c2
c(4,4)=c3
c(5,5)=c3
c(6,6)=c3

end subroutine make_c

!------------

subroutine compute_stress (x,y,z,uvw,stress,nn,ne,icon,ym,pr)

! this routine computes the stress tensor
! using a classical elastic theory

implicit none

integer nn,ne
double precision x(nn),y(nn),z(nn),uvw(3*nn)
double precision stress(6,ne),strain(6)
integer icon(8,ne)
integer ie,i,ic
double precision h(8),dhdr(8),dhds(8),dhdt(8),dhdx(8),dhdy(8),dhdz(8)
double precision r,s,t,jcb(3,3),volume,jcbi(3,3)
double precision c11,c12,c22,ym,pr

do ie=1,ne

r=0.d0
s=0.d0
t=0.d0

h(1)=(1.d0-r)*(1.d0-s)*(1.d0-t)/8.d0
h(2)=(1.d0+r)*(1.d0-s)*(1.d0-t)/8.d0
h(3)=(1.d0-r)*(1.d0+s)*(1.d0-t)/8.d0
h(4)=(1.d0+r)*(1.d0+s)*(1.d0-t)/8.d0
h(5)=(1.d0-r)*(1.d0-s)*(1.d0+t)/8.d0
h(6)=(1.d0+r)*(1.d0-s)*(1.d0+t)/8.d0
h(7)=(1.d0-r)*(1.d0+s)*(1.d0+t)/8.d0
h(8)=(1.d0+r)*(1.d0+s)*(1.d0+t)/8.d0

dhdr(1)=-(1.d0-s)*(1.d0-t)/8.d0
dhdr(2)=(1.d0-s)*(1.d0-t)/8.d0
dhdr(3)=-(1.d0+s)*(1.d0-t)/8.d0
dhdr(4)=(1.d0+s)*(1.d0-t)/8.d0
dhdr(5)=-(1.d0-s)*(1.d0+t)/8.d0
dhdr(6)=(1.d0-s)*(1.d0+t)/8.d0
dhdr(7)=-(1.d0+s)*(1.d0+t)/8.d0
dhdr(8)=(1.d0+s)*(1.d0+t)/8.d0

dhds(1)=-(1.d0-r)*(1.d0-t)/8.d0
dhds(2)=-(1.d0+r)*(1.d0-t)/8.d0
dhds(3)=(1.d0-r)*(1.d0-t)/8.d0
dhds(4)=(1.d0+r)*(1.d0-t)/8.d0
dhds(5)=-(1.d0-r)*(1.d0+t)/8.d0
dhds(6)=-(1.d0+r)*(1.d0+t)/8.d0
dhds(7)=(1.d0-r)*(1.d0+t)/8.d0
dhds(8)=(1.d0+r)*(1.d0+t)/8.d0

dhdt(1)=-(1.d0-r)*(1.d0-s)/8.d0
dhdt(2)=-(1.d0+r)*(1.d0-s)/8.d0
dhdt(3)=-(1.d0-r)*(1.d0+s)/8.d0
dhdt(4)=-(1.d0+r)*(1.d0+s)/8.d0
dhdt(5)=(1.d0-r)*(1.d0-s)/8.d0
dhdt(6)=(1.d0+r)*(1.d0-s)/8.d0
dhdt(7)=(1.d0-r)*(1.d0+s)/8.d0
dhdt(8)=(1.d0+r)*(1.d0+s)/8.d0

jcb=0.
  do i=1,8
  ic=icon(i,ie)
  jcb(1,1)=jcb(1,1)+dhdr(i)*x(ic)
  jcb(1,2)=jcb(1,2)+dhdr(i)*y(ic)
  jcb(1,3)=jcb(1,3)+dhdr(i)*z(ic)
  jcb(2,1)=jcb(2,1)+dhds(i)*x(ic)
  jcb(2,2)=jcb(2,2)+dhds(i)*y(ic)
  jcb(2,3)=jcb(2,3)+dhds(i)*z(ic)
  jcb(3,1)=jcb(3,1)+dhdt(i)*x(ic)
  jcb(3,2)=jcb(3,2)+dhdt(i)*y(ic)
  jcb(3,3)=jcb(3,3)+dhdt(i)*z(ic)
  enddo

volume=jcb(1,1)*jcb(2,2)*jcb(3,3) &
      +jcb(1,2)*jcb(2,3)*jcb(3,1) &
      +jcb(2,1)*jcb(3,2)*jcb(1,3) &
      -jcb(1,3)*jcb(2,2)*jcb(3,1) &
      -jcb(1,2)*jcb(2,1)*jcb(3,3) &
      -jcb(2,3)*jcb(3,2)*jcb(1,1)

jcbi(1,1)=(jcb(2,2)*jcb(3,3)-jcb(2,3)*jcb(3,2))/volume
jcbi(2,1)=(jcb(2,3)*jcb(3,1)-jcb(2,1)*jcb(3,3))/volume
jcbi(3,1)=(jcb(2,1)*jcb(3,2)-jcb(2,2)*jcb(3,1))/volume
jcbi(1,2)=(jcb(1,3)*jcb(3,2)-jcb(1,2)*jcb(3,3))/volume
jcbi(2,2)=(jcb(1,1)*jcb(3,3)-jcb(1,3)*jcb(3,1))/volume
jcbi(3,2)=(jcb(1,2)*jcb(3,1)-jcb(1,1)*jcb(3,2))/volume
jcbi(1,3)=(jcb(1,2)*jcb(2,3)-jcb(1,3)*jcb(2,2))/volume
jcbi(2,3)=(jcb(1,3)*jcb(2,1)-jcb(1,1)*jcb(2,3))/volume
jcbi(3,3)=(jcb(1,1)*jcb(2,2)-jcb(1,2)*jcb(2,1))/volume

  do i=1,8
  dhdx(i)=jcbi(1,1)*dhdr(i)+jcbi(1,2)*dhds(i)+jcbi(1,3)*dhdt(i)
  dhdy(i)=jcbi(2,1)*dhdr(i)+jcbi(2,2)*dhds(i)+jcbi(2,3)*dhdt(i)
  dhdz(i)=jcbi(3,1)*dhdr(i)+jcbi(3,2)*dhds(i)+jcbi(3,3)*dhdt(i)
  enddo

c11=ym*(1.d0-pr)/(1.d0+pr)/(1.d0-2.d0*pr)
c12=c11*pr/(1.d0-pr)
c22=c11*(1.d0-2.d0*pr)/(1.d0-pr)

strain(:)=0.d0
  do i=1,8
  ic=icon(i,ie)
  strain(1)=strain(1)+dhdx(i)*uvw(ic*3-2)
  strain(2)=strain(2)+dhdy(i)*uvw(ic*3-1)
  strain(3)=strain(3)+dhdz(i)*uvw(ic*3-0)
  strain(4)=strain(4)+(dhdx(i)*uvw(ic*3-1)+dhdy(i)*uvw(ic*3-2))/2.d0
  strain(5)=strain(5)+(dhdz(i)*uvw(ic*3-2)+dhdx(i)*uvw(ic*3-0))/2.d0
  strain(6)=strain(6)+(dhdy(i)*uvw(ic*3-0)+dhdz(i)*uvw(ic*3-1))/2.d0
  enddo
stress(1,ie)=c11*strain(1)+c12*(strain(2)+strain(3))
stress(2,ie)=c11*strain(2)+c12*(strain(1)+strain(3))
stress(3,ie)=c11*strain(3)+c12*(strain(1)+strain(2))
stress(4,ie)=c22*strain(4)
stress(5,ie)=c22*strain(5)
stress(6,ie)=c22*strain(6)

enddo

end subroutine compute_stress

!--------------

subroutine plastic (c,stress,ks)

! subroutine to compute the plasticity effect (how failure changes the elastic matrix/properties)

implicit none

double precision c(6,6),stress(6),ks
double precision s(6),p,s2d,fail,cs(6),scs
integer i,j

s=stress
p=sum(stress(1:3))/3.d0
s(1:3)=stress(1:3)-p
s2d=0.5d0*sum(s(1:3)**2)+sum(s(4:6)**2)
fail=sqrt(max(1.d0,s2d/ks**2))

  if (fail.gt.1.d0) then
  s=s/fail
    do i=1,6
    cs(i)=0.d0
      do j=1,6
      cs(i)=cs(i)+c(i,j)*s(j)
      enddo
    enddo
  scs=0.d0
    do i=1,6
    scs=scs+s(i)*cs(i)
    enddo
    do i=1,6
      do j=1,6
      c(i,j)=c(i,j)-cs(i)*cs(j)/scs
      enddo
    enddo
  endif
end subroutine plastic

!---------------

subroutine check_convergence (stress,stressp,converge,ne)

! subroutine to check if the stresses change between two iterations
! if the stress level has not changed, relatively, by more than epsilon, converge is set to true

double precision stress(6,ne),stressp(6,ne)
logical converge
integer ne
double precision epsilon,diff,sumstress

epsilon=1.d-3
converge=.false.
sumstress=sum(stress**2)
diff=1.
if (sumstress.gt.0.d0) diff=sum((stress-stressp)**2)/sum(stress**2)
if (diff.lt.epsilon) converge=.true.
print*,'Convergence ratio',diff

stressp=stress

return
end